# 한정판 상품 주문 처리 시스템 설계 - 면접 발표 스크립트 (15분)

안녕하세요. 오늘은 한정판 상품 주문 처리 시스템 설계에 대해 발표드리겠습니다.

## 1. 문제 상황과 해결해야 할 과제 (2분)

**상황**: 온라인 쇼핑몰에서 **한정판 스니커즈 100켤레**를 판매합니다. 오픈 5분 전부터 수만 명이 대기하고 있고, 오픈과 동시에 **초당 5천 건의 주문**이 몰립니다.

이때 반드시 지켜야 할 규칙들:
- **절대 101켤레가 팔려서는 안 됩니다** (초과 주문 방지)
- **한 사람당 1켤레만** 구매 가능
- **더블클릭이나 새로고침해도 중복 주문되면 안 됩니다** (멱등성)
- **서버가 죽어도 이미 예약된 건은 보장**되어야 합니다

이런 상황에서 우리가 직면하는 **4가지 핵심 도전**:

1. **🔥 동시성 지옥**: 5천 명이 동시에 "마지막 1켤레"를 노릴 때 어떻게 처리할까?
2. **⚡ 재고 정확성**: 실시간으로 정확한 재고를 유지하면서 성능도 보장해야 함
3. **🔄 중복 요청**: 사용자가 답답해서 연타하거나 네트워크 재시도 발생
4. **💥 장애 상황**: 결제 진행 중 서버가 죽으면 예약은 어떻게 될까?

**목표**: 이 모든 문제를 해결하면서도 **빠르고 안정적인 시스템**을 만드는 것입니다.

## 2. 해결책: 마트 비유로 이해하는 시스템 (3분)

이제 우리의 해결책을 설명드리겠습니다. 이해하기 쉽게 **한정판 과자를 파는 마트**에 비유해서 말씀드릴게요.

### 🏪 마트 구조 (테이블 설계)

먼저 우리 마트에는 다섯 가지 핵심 요소가 있습니다. 

**재고 창고**가 있습니다. 이것이 바로 `inventory_counter` 테이블인데, 실시간 재고 현황판 역할을 합니다. "남은 과자: 100개" 이렇게 보여주는 거죠.

**예약 명단**도 있습니다. `reservation_hold` 테이블로, "홍길동님, 과자 1개, 10분간 예약됨" 이런 식으로 누가 언제까지 예약했는지 기록합니다.

**감사 일지**는 `inventory_ledger` 테이블입니다. 모든 재고 변화를 기록하죠. "언제, 누가, 몇 개 가져갔는지" 모든 것을 남깁니다.

**중복 방지 장부**인 `idempotency` 테이블은 "같은 요청은 한 번만 처리"를 보장합니다.

마지막으로 **방송 안내판**인 `event_outbox`는 다른 부서에 알릴 메시지를 적어두는 곳입니다.

### 🔄 3단계 구매 흐름

이제 실제 구매 과정을 보겠습니다.

**1단계는 T1 예약 단계입니다.** 손님이 "과자 1개 주세요!"라고 하면, 점원이 6가지 일을 순서대로 합니다. 먼저 같은 손님이 이미 주문했는지 확인하고, 1인 1개 제한을 체크합니다. 그 다음 창고에서 조건부로 1개를 빼고, 예약 명단에 이름과 5분 만료 시간을 적습니다. 마지막으로 가계부에 기록하고 다른 부서에 알릴 메시지를 준비해둡니다. 이 6단계가 모두 성공해야만 예약이 완료됩니다.

**2단계는 T2 확정 단계입니다.** 손님이 "카드로 결제할게요!"라고 하면, 점원이 5가지 절차를 거칩니다. 먼저 같은 결제가 중복으로 들어왔는지 확인하고, 예약 명단에서 해당 예약을 찾아 락을 걸어 다른 점원이 동시에 처리하지 못하게 합니다. 예약이 유효한지 확인한 후 주문서를 작성하고, 예약 상태를 "확정됨"으로 바꿉니다. 마지막으로 주문 기록을 남기고 배송팀에 알림을 보냅니다.

**3단계는 T3 정리 단계입니다.** 백그라운드에서 청소 직원이 주기적으로 돌면서 4가지 작업을 합니다. 5분이 지나도 결제하지 않은 예약들을 찾아서 "만료됨"으로 상태를 바꾸고, 묶여있던 재고를 다시 판매 가능 상태로 복원합니다. 그리고 이 모든 변화를 가계부에 기록하고 재고 관리팀에 알림을 보냅니다. 이때 다른 점원이 처리 중인 예약은 건너뛰어 충돌을 방지합니다.

### 🛡️ 핵심 안전장치들

이 시스템에는 세 가지 핵심 안전장치가 있습니다.

**첫째는 동시성 보호입니다.** 여러 명이 마지막 1개를 노려도 조건부 UPDATE로 한 명만 성공하게 만듭니다. "남은 개수가 1개 이상일 때만 1개 빼기" 이런 조건을 걸어두는 거죠.

**둘째는 중복 방지입니다.** 같은 사람이 여러 번 주문해도 멱등성 키로 첫 번째만 처리합니다.

**셋째는 직렬화입니다.** 같은 예약에 동시에 접근할 때 FOR UPDATE로 한 줄 서기를 시킵니다.

## 3. 핵심 문제별 해결책 (6분)

이제 각 문제별로 구체적인 해결책을 설명드리겠습니다.

### 3-1. 🚫 초과 주문 방지: "101켤레 절대 안 팔기" (2분)

가장 중요한 문제인 초과 주문 방지부터 설명드리겠습니다. 

많은 개발자들이 하는 실수가 있습니다. 먼저 SELECT로 재고를 확인하고, 그 다음에 UPDATE로 차감하는 방식입니다. 이렇게 하면 어떤 일이 벌어질까요?

```sql
-- 위험한 방식 (레이스 컨디션 발생)
SELECT available FROM inventory WHERE sku_id = 123;  -- 둘 다 100개 확인
UPDATE inventory SET available = available - 1;      -- 둘 다 차감해서 98개가 됨
```

두 개의 요청이 거의 동시에 들어오면, 둘 다 "100개가 있네요"라고 확인한 후, 둘 다 차감해버립니다. 그러면 재고가 98개가 되어버리죠. 이게 바로 레이스 컨디션입니다.

**우리의 해결책은 조건부 원자적 UPDATE입니다.** 이렇게 작동합니다:

```sql
-- 안전한 방식 (한 번에 확인+차감)
UPDATE inventory_counter 
SET available = available - 1 
WHERE sku_id = 123 AND available >= 1;

-- 성공했나 확인
IF ROW_COUNT() = 1 THEN
  -- 성공: 재고 차감됨, 예약 생성 진행
ELSE 
  -- 실패: 재고 부족, 즉시 실패 응답
END IF;
```

이 방식의 핵심은 세 가지입니다. 첫째, **원자성**입니다. 확인과 차감이 동시에 일어나므로 그 사이에 다른 요청이 끼어들 틈이 없습니다. 둘째, **조건부 처리**입니다. available이 1 이상일 때만 차감하므로 음수가 될 수 없습니다. 셋째, **즉시 실패**입니다. 재고가 부족하면 기다리지 않고 바로 실패 응답을 줍니다.

결국 5천 명이 동시에 마지막 1켤레를 노려도, 데이터베이스가 한 명만 성공시키고 나머지는 즉시 실패로 처리하게 됩니다.

### 3-2. 🔄 중복 요청 방지: "더블클릭해도 한 번만" (2분)

두 번째 문제는 중복 요청입니다. 실제 서비스에서는 이런 일들이 자주 발생합니다. 사용자가 답답해서 구매 버튼을 여러 번 클릭하거나, 결제사에서 웹훅을 중복으로 보내거나, 네트워크가 불안정해서 자동으로 재시도가 일어나죠.

**우리는 T1과 T2에서 각각 다른 방식으로 이 문제를 해결합니다.**

**T1에서는 멱등성 키를 사용한 중복 방지를 합니다.** 트랜잭션을 시작하자마자 "내가 이 요청을 처리한다"는 깃발을 꽂는 거죠. 이것이 T1의 첫 번째 단계입니다:

```sql
-- 같은 요청은 한 번만 통과
INSERT INTO idempotency(user_id, idem_key, status) 
VALUES('홍길동', 'abc-123', 'IN_PROGRESS')
ON DUPLICATE KEY UPDATE idem_key = idem_key;  -- 이미 있으면 무시

-- 새로 들어갔나 확인
IF ROW_COUNT() = 1 THEN
  -- 내가 첫 번째 요청: 계속 진행
ELSE 
  -- 이미 처리 중이거나 완료: 기존 결과 반환하고 종료
END IF;
```

이 테이블은 사용자 ID와 멱등성 키의 조합에 유니크 제약이 걸려있어서, 같은 요청이 두 번 들어와도 한 번만 통과시킵니다.

**T2에서는 FOR UPDATE를 사용한 직렬화를 합니다.** 결제 확정 시에 같은 예약에 동시에 접근하는 요청들을 한 줄로 세우는 거죠. 이것이 T2의 두 번째 단계입니다:

```sql
-- 예약 정보를 락 걸고 가져오기
SELECT * FROM reservation_hold 
WHERE hold_id = 'hold_12345' 
FOR UPDATE;  -- 이 예약을 다른 요청이 못 건드리게 락

-- 상태 확인
IF status = 'HOLD' AND expire_at > NOW() THEN
  -- 유효한 예약: 주문 생성 진행
ELSE
  -- 이미 확정되었거나 만료됨: 적절한 응답 반환
END IF;
```

실제로 어떻게 작동하는지 보면, 첫 번째 서버가 예약에 락을 걸고 주문을 생성한 후 상태를 "COMMITTED"로 변경하고 커밋합니다. 두 번째 서버는 락이 풀릴 때까지 대기했다가, 이미 확정된 상태를 확인하고 "이미 처리됨" 응답을 반환합니다. 이렇게 같은 예약에 대해 절대 두 개의 주문이 생성될 수 없습니다.

결국 T1에서는 멱등성으로 같은 예약 요청을 차단하고, T2에서는 FOR UPDATE로 같은 예약의 동시 확정을 방지하는 이중 안전장치를 구축한 것이 핵심입니다.

### 3-3. 💥 장애 복구: "서버 죽어도 데이터는 살아있다" (2분)

세 번째 문제는 장애 상황에서의 복구입니다. 실제 서비스에서는 여러 가지 문제가 발생할 수 있습니다. T1 도중 서버가 크래시되거나, T2 처리 중 네트워크가 단절되거나, 사용자가 결제를 안 하고 사라지는 경우들이죠.

**우리는 T3 트랜잭션과 함께 세 가지 핵심 안전장치를 준비했습니다.**

**첫 번째는 T3 만료 청소기입니다.** 백그라운드에서 주기적으로 실행되는 4단계 청소 프로세스입니다. 매 10초마다 돌면서 만료된 예약들을 찾고, 상태를 "EXPIRED"로 바꾸고, 묶여있던 재고를 복원하고, 모든 변화를 기록합니다:

```sql
-- 만료된 예약들 찾기 (SKIP LOCKED로 충돌 회피)
SELECT hold_id, sku_id, qty 
FROM reservation_hold 
WHERE status='HOLD' AND expire_at <= NOW() 
FOR UPDATE SKIP LOCKED 
LIMIT 1000;

-- 한 번에 정리 (원자적 처리)
UPDATE reservation_hold SET status='EXPIRED' WHERE hold_id IN (:ids);
UPDATE inventory_counter SET available = available + :qty WHERE sku_id = :sku;
INSERT INTO inventory_ledger VALUES ('만료로 인한 재고 복원', +qty, hold_id);
```

여기서 중요한 것은 SKIP LOCKED입니다. 만약 T2 결제 처리가 어떤 예약을 잡고 있으면, 그건 건너뛰고 다른 것을 처리합니다. 이렇게 T2와 T3가 동시에 실행되어도 충돌 없이 안전하게 처리됩니다.

**두 번째는 원장 기반 복구입니다.** T1, T2, T3 모든 단계에서 재고 변화를 원장에 기록해서 나중에 검증할 수 있게 만들었습니다. 주기적으로 이 쿼리를 실행해서 불일치를 감지하고 자동 복구합니다:

```sql
-- 원장과 카운터 일치 확인
SELECT sku_id, 
       SUM(qty_delta) as ledger_total,      -- 원장 합계
       (SELECT available FROM inventory_counter WHERE sku_id = l.sku_id) as counter_value
FROM inventory_ledger l 
GROUP BY sku_id
HAVING ledger_total != counter_value;  -- 불일치 발견 시 복구
```

원장의 합계와 카운터 값이 다르면 문제가 있다는 신호이므로, 즉시 복구할 수 있습니다.

**세 번째는 아웃박스 패턴입니다.** T1, T2, T3 모든 단계에서 이벤트 유실을 방지하기 위한 안전한 메시지 전송 방식을 사용합니다:

```sql
-- 재고 변화와 이벤트를 같은 트랜잭션에서 처리
BEGIN;
  UPDATE inventory_counter SET available = available - 1;
  INSERT INTO event_outbox VALUES ('재고감소', sku_id, qty);  -- 이벤트도 함께 저장
COMMIT;
```

재고 변화와 이벤트 기록을 같은 트랜잭션에서 처리하므로, 둘 중 하나만 성공하는 일은 없습니다. 또한 T3에서는 멱등성을 보장해서 같은 만료 처리가 여러 번 실행되어도 안전합니다.

결국 3개 트랜잭션이 서로 협력하면서 데이터베이스의 ACID 속성과 원장을 통해 어떤 장애가 발생해도 데이터 일관성을 보장하는 것이 핵심입니다.

## 4. 성능 최적화 전략 (2분)

마지막으로 성능 최적화 전략에 대해 말씀드리겠습니다. 초당 5천 건의 요청을 처리하려면 단순히 기능만 구현해서는 안 되고, 성능도 최적화해야 합니다.

**첫 번째는 인덱스 설계입니다.** 우리가 자주 사용하는 쿼리 패턴을 분석해서 적절한 인덱스를 만들었습니다. 만료 스캔을 위한 expire_at 인덱스, 사용자별 예약 조회를 위한 복합 인덱스, 원장 조회를 위한 시간 기반 인덱스들입니다. 이런 인덱스가 없으면 테이블 전체를 스캔해야 해서 성능이 급격히 떨어집니다.

**두 번째는 배치 처리입니다.** T3 만료 청소를 한 번에 1000건씩 청크로 나누어 처리하고, 아웃박스 이벤트 전송도 비동기 배치로 처리해서 DB 부하를 분산시킵니다. 한 번에 너무 많이 처리하면 락이 오래 걸려서 다른 요청들이 대기하게 되거든요.

**세 번째는 파티셔닝입니다.** 데이터의 성격에 따라 다른 파티셔닝 전략을 적용했습니다. 원장이나 로그같이 시간 순으로 쌓이는 데이터는 시간 기준으로 파티셔닝하고, 재고나 예약같이 자주 업데이트되는 핫 테이블은 SKU 기준으로 파티셔닝해서 부하를 분산시킵니다.

**네 번째는 읽기와 쓰기 분리입니다.** 쓰기 작업은 반드시 주 데이터베이스에서 강한 일관성을 보장하지만, 읽기 작업은 리플리카나 캐시에서 처리해서 주 DB의 부하를 줄입니다. 다만 중요한 의사결정은 반드시 주 DB에서 해야 한다는 점을 잊으면 안 됩니다.

## 5. 마무리 및 핵심 메시지 (1분)

지금까지 한정판 상품 주문 처리 시스템에 대해 설명드렸습니다.

우리가 해결한 핵심을 트랜잭션별로 정리하면, **T1에서는 6단계 예약 프로세스와 조건부 원자적 UPDATE**로 초과 주문을 방지하고, **T2에서는 5단계 확정 프로세스와 FOR UPDATE 직렬화**로 중복 확정을 막으며, **T3에서는 4단계 만료 처리와 SKIP LOCKED 충돌 회피**로 안전한 재고 복원을 보장했습니다.

또한 모든 트랜잭션에서 **멱등성, 원장 기록, 아웃박스 패턴**을 일관되게 적용해서 어떤 장애 상황에서도 데이터 일관성을 유지할 수 있게 만들었습니다.

가장 중요한 것은 **3단계로 분리된 명확한 책임과 견고한 설계**입니다. 복잡한 기술을 많이 쓰는 것보다는, 데이터베이스의 트랜잭션과 락 메커니즘을 제대로 활용해서 확실한 보장을 만드는 것이 더 중요합니다.

실제 서비스에서는 T1, T2, T3가 서로 협력하는 이런 기본기가 탄탄해야 높은 트래픽 상황에서도 안정적으로 동작할 수 있습니다.

## Q&A

이상으로 발표를 마치겠습니다. 질문이 있으시면 답변드리겠습니다.

---

**📝 발표 팁:**
- 각 섹션별로 시간을 체크하며 진행
- 코드보다는 개념 설명에 집중
- 면접관의 반응을 보며 속도 조절
- 실무 경험과 연결해서 설명하면 더 좋음

*발표 시간: 약 15분 (Q&A 포함)*
*핵심 메시지: "단순하고 견고한 설계로 복잡한 문제를 해결한다"*
