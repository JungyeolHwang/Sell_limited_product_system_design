# T1, T2, T3 트랜잭션 완전 가이드
## 초보자를 위한 단계별 상세 설명

---

## 📖 목차

1. [전체 개요](#전체-개요)
2. [T1 트랜잭션: 예약하기](#t1-트랜잭션-예약하기)
3. [T2 트랜잭션: 결제하기](#t2-트랜잭션-결제하기)
4. [T3 트랜잭션: 정리하기](#t3-트랜잭션-정리하기)
5. [트랜잭션 간 상호작용](#트랜잭션-간-상호작용)
6. [장애 상황별 대응](#장애-상황별-대응)

---

## 전체 개요

### 🎯 한정판 상품 구매는 3단계로 이루어집니다

한정판 스니커즈 100켤레를 온라인으로 판매한다고 생각해보세요. 수만 명이 동시에 구매 버튼을 누를 때, 어떻게 정확히 100켤레만 팔 수 있을까요?

우리는 **3단계 트랜잭션**으로 이 문제를 해결합니다:

```
🛒 T1: 예약하기    →    💳 T2: 결제하기    →    🧹 T3: 정리하기
  (5분간 찜)           (진짜 구매)            (안 산 것 치우기)
```

### 🏪 마트 비유로 이해하기

**상황**: 편의점에서 한정판 과자 100개를 판매합니다.

- **T1 (예약)**: 손님이 "과자 1개 주세요!" → 점원이 과자를 따로 빼두고 "5분 안에 결제하세요" 메모지 붙임
- **T2 (결제)**: 손님이 카드로 결제 → 점원이 "결제 완료" 도장 찍고 포장해줌  
- **T3 (정리)**: 5분 지나도 결제 안 한 과자들 → 점원이 다시 진열대에 올려놓음

이렇게 하면 **절대 101개가 팔릴 수 없습니다!**

---

## T1 트랜잭션: 예약하기

### 🎯 목표
사용자가 "구매" 버튼을 눌렀을 때, 재고를 안전하게 예약하기

### 📋 처리 순서 (6단계)

#### 1단계: 중복 요청 방지 (멱등성 체크)

**무엇을 하나요?**
- 같은 사람이 구매 버튼을 여러 번 눌러도 한 번만 처리되게 합니다

**왜 필요한가요?**
- 사용자가 답답해서 구매 버튼을 연타할 수 있어요
- 네트워크 문제로 요청이 여러 번 갈 수 있어요

**어떻게 하나요?**
```sql
-- "이 요청은 내가 처리 중이야" 깃발 꽂기
INSERT INTO idempotency(user_id, idem_key, status) 
VALUES('홍길동', 'abc-123', 'IN_PROGRESS')
ON DUPLICATE KEY UPDATE idem_key = idem_key;

-- 새로 들어갔나 확인
IF ROW_COUNT() = 1 THEN
  -- 내가 첫 번째 요청: 계속 진행
ELSE 
  -- 이미 처리 중: 기존 결과 반환하고 종료
END IF;
```

**실생활 비유**: 은행에서 번호표 뽑기. 같은 번호표는 한 번만 뽑을 수 있어요.

---

#### 2단계: 한 사람당 1개 제한 체크

**무엇을 하나요?**
- 같은 사람이 여러 개 구매하는 것을 방지합니다

**왜 필요한가요?**
- 한정판은 보통 "1인 1개" 제한이 있어요
- 한 사람이 여러 브라우저로 동시에 주문할 수 있어요

**어떻게 하나요?**
```sql
-- 이미 예약한 게 있는지 확인
INSERT INTO user_active_hold(sale_id, user_id, sku_id) 
VALUES(세일ID, '홍길동', '스니커즈ID')
ON DUPLICATE KEY UPDATE sale_id = sale_id;

IF ROW_COUNT() = 0 THEN
  -- 이미 예약했음: 거절
  ROLLBACK;
END IF;
```

**실생활 비유**: 콘서트 티켓 예매할 때 "1인 4매 한정" 체크하는 것과 같아요.

---

#### 3단계: 재고 차감 (가장 중요!)

**무엇을 하나요?**
- 전체 재고에서 주문 수량만큼 빼기

**왜 중요한가요?**
- 여기서 실수하면 101개가 팔릴 수 있어요!
- 동시에 1000명이 마지막 1개를 노릴 때도 안전해야 해요

**❌ 잘못된 방법:**
```sql
-- 위험한 방식 (절대 이렇게 하면 안 됨!)
SELECT available FROM inventory WHERE sku_id = 123;  -- 100개 확인
-- 잠깐의 틈...
UPDATE inventory SET available = available - 1;      -- 차감
```
→ 두 명이 동시에 하면 둘 다 100개를 보고 둘 다 차감해서 98개가 됨!

**✅ 올바른 방법:**
```sql
-- 안전한 방식 (한 번에 확인+차감)
UPDATE inventory_counter 
SET available = available - 1 
WHERE sku_id = 123 AND available >= 1;

-- 실제로 차감됐는지 확인
IF ROW_COUNT() = 1 THEN
  -- 성공: 재고 1개 차감됨
ELSE 
  -- 실패: 재고 부족, 주문 거절
  ROLLBACK;
END IF;
```

**실생활 비유**: 
- ❌ 나쁜 예: 냉장고 확인 → 우유 있네 → 마트 가서 우유 사기 (그 사이 가족이 우유 다 마실 수 있음)
- ✅ 좋은 예: 냉장고에서 우유를 직접 꺼내기 (없으면 꺼낼 수 없음)

---

#### 4단계: 예약 기록 생성

**무엇을 하나요?**
- "홍길동님이 스니커즈 1켤레를 5분간 예약했음" 기록하기

**왜 필요한가요?**
- 결제할 때 "내가 진짜 예약한 게 맞나?" 확인하려고
- 5분 후에 자동으로 취소하려고

**어떻게 하나요?**
```sql
INSERT INTO reservation_hold(
  hold_id, user_id, sku_id, qty, status, expire_at
) VALUES(
  'hold_12345', '홍길동', '스니커즈ID', 1, 'HOLD', NOW() + INTERVAL 5 MINUTE
);
```

**실생활 비유**: 레스토랑에서 테이블 예약할 때 "홍길동님, 4인석, 7시, 10분 후 취소" 이렇게 적는 것

---

#### 5단계: 감사 기록 (영수증)

**무엇을 하나요?**
- "언제, 누가, 무엇을, 왜" 재고가 변했는지 영구 기록

**왜 필요한가요?**
- 나중에 문제 생겼을 때 추적하려고
- 재고 숫자가 안 맞을 때 원인 찾으려고

**어떻게 하나요?**
```sql
INSERT INTO inventory_ledger(
  sku_id, event_type, qty_delta, hold_id, reason, created_at
) VALUES(
  '스니커즈ID', 'RESERVE_DEBIT', -1, 'hold_12345', '예약으로 인한 차감', NOW()
);
```

**실생활 비유**: 가계부에 "2024-01-15, 스니커즈 예약, -1개, 홍길동" 이렇게 적어두는 것

---

#### 6단계: 이벤트 발송 준비 (아웃박스)

**무엇을 하나요?**
- 다른 시스템들에게 "예약 발생했어요!" 알림 준비

**왜 필요한가요?**
- 재고 관리 시스템에 알려야 해요
- 마케팅 시스템에서 "남은 재고 99개" 업데이트해야 해요

**어떻게 하나요?**
```sql
INSERT INTO event_outbox(
  event_type, payload, created_at
) VALUES(
  'ReservationCreated', 
  '{"user_id":"홍길동", "sku_id":"스니커즈ID", "qty":1}',
  NOW()
);
```

**실생활 비유**: 우체통에 편지 넣어두기. 우체부(이벤트 발송 서비스)가 나중에 배달해줌

---

### 🎯 T1 전체 흐름 정리

```sql
START TRANSACTION;  -- 트랜잭션 시작

-- 1) 중복 방지
INSERT INTO idempotency(...) ON DUPLICATE KEY UPDATE ...;

-- 2) 1인 1개 체크  
INSERT INTO user_active_hold(...) ON DUPLICATE KEY UPDATE ...;

-- 3) 재고 차감 (핵심!)
UPDATE inventory_counter SET available = available - 1 
WHERE sku_id = 123 AND available >= 1;

-- 4) 예약 생성
INSERT INTO reservation_hold(...);

-- 5) 감사 기록
INSERT INTO inventory_ledger(...);

-- 6) 이벤트 준비
INSERT INTO event_outbox(...);

COMMIT;  -- 모든 것을 한 번에 확정

-- 성공 응답
RETURN { "hold_id": "hold_12345", "expire_at": "2024-01-15 14:05:00" };
```

**중요**: 이 6단계가 **모두 성공하거나 모두 실패**합니다. 중간에 하나라도 실패하면 전부 취소돼요!

---

## T2 트랜잭션: 결제하기

### 🎯 목표
결제가 완료되면 예약을 진짜 주문으로 바꾸기

### 🎬 시나리오
1. 사용자가 T1으로 스니커즈를 예약함
2. 결제 페이지에서 카드 정보 입력
3. 외부 결제사(PG)에서 결제 성공
4. 결제사가 우리 서버에 "결제 됐어요!" 알림 (웹훅)
5. **T2 트랜잭션 시작!**

### 📋 처리 순서 (5단계)

#### 1단계: 결제 중복 방지 (멱등성 체크)

**무엇을 하나요?**
- 같은 결제 건이 여러 번 들어와도 한 번만 처리

**왜 필요한가요?**
- 결제사에서 웹훅을 여러 번 보낼 수 있어요
- 네트워크 문제로 재시도가 일어날 수 있어요

**어떻게 하나요?**
```sql
-- 이미 처리한 결제인지 확인
SELECT response_json FROM idempotency 
WHERE user_id = '홍길동' AND idem_key = 'payment_abc123';

IF FOUND THEN
  -- 이미 처리됨: 기존 결과 반환하고 종료
  RETURN stored_response;
END IF;

-- 새로운 결제: "처리 중" 표시
INSERT INTO idempotency(user_id, idem_key, status) 
VALUES('홍길동', 'payment_abc123', 'IN_PROGRESS');
```

**실생활 비유**: 은행에서 같은 수표를 두 번 현금화하려고 해도 한 번만 됨

---

#### 2단계: 예약 유효성 확인 + 잠금 (가장 중요!)

**무엇을 하나요?**
- 내가 예약한 게 아직 살아있는지 확인
- 다른 사람이 동시에 건드리지 못하게 잠금

**왜 이 단계가 중요한가요?**
- 예약이 만료됐을 수도 있어요 (5분 지남)
- 같은 예약에 대해 여러 결제가 동시에 올 수도 있어요

**어떻게 하나요?**
```sql
-- 예약 정보를 락 걸고 가져오기
SELECT user_id, sku_id, qty, status, expire_at
FROM reservation_hold 
WHERE hold_id = 'hold_12345' 
FOR UPDATE;  -- 🔒 다른 트랜잭션이 이 행을 못 건드리게 락!

-- 유효성 검사
IF status != 'HOLD' THEN
  ROLLBACK; -- 이미 확정되거나 만료됨
END IF;

IF expire_at <= NOW() THEN
  ROLLBACK; -- 시간 만료
END IF;

IF user_id != '홍길동' THEN
  ROLLBACK; -- 다른 사람 예약
END IF;
```

**FOR UPDATE가 중요한 이유:**

```
시간 순서:
서버 A: 예약 확인 (HOLD 상태) → 주문 생성 → 상태 변경 → 커밋
서버 B: 예약 확인 (대기...) → A 커밋 후 → 이미 COMMITTED 확인 → 중단

FOR UPDATE 없으면:
서버 A: 예약 확인 (HOLD 상태) → 주문 생성 → 상태 변경 → 커밋  
서버 B: 예약 확인 (HOLD 상태) → 주문 생성 → 상태 변경 → 커밋
결과: 주문 2개 생성! 💥
```

**실생활 비유**: 도서관에서 책 대출할 때, 사서가 책을 들고 있는 동안 다른 사람이 못 가져가는 것

---

#### 3단계: 주문 생성

**무엇을 하나요?**
- 진짜 주문 레코드 만들기

**어떻게 하나요?**
```sql
-- 주문 번호 생성
SET @order_id = generate_order_id();

-- 주문 생성
INSERT INTO orders(
  order_id, user_id, status, total_amount, hold_id, created_at
) VALUES(
  @order_id, '홍길동', 'CONFIRMED', 150000, 'hold_12345', NOW()
);

-- 주문 상품 정보
INSERT INTO order_items(
  order_id, sku_id, qty, price
) VALUES(
  @order_id, '스니커즈ID', 1, 150000
);
```

**실생활 비유**: 레스토랑에서 주문표 작성하는 것

---

#### 4단계: 예약 확정

**무엇을 하나요?**
- 예약 상태를 'HOLD'에서 'COMMITTED'로 변경

**왜 3단계와 4단계를 같이 해야 하나요?**
- 주문은 생성됐는데 예약은 HOLD 상태로 남으면 안 되거든요
- 둘 다 성공하거나 둘 다 실패해야 해요

**어떻게 하나요?**
```sql
-- 예약 확정
UPDATE reservation_hold 
SET status = 'COMMITTED', updated_at = NOW()
WHERE hold_id = 'hold_12345' AND status = 'HOLD';

-- 1인 1개 제한 해제 (더 이상 예약 중이 아니므로)
DELETE FROM user_active_hold 
WHERE user_id = '홍길동' AND hold_id = 'hold_12345';
```

**실생활 비유**: 도서관에서 예약 도서를 대출로 바꾸는 것

---

#### 5단계: 기록 및 이벤트

**무엇을 하나요?**
- 주문 확정 기록 남기기
- 다른 시스템들에게 알림 준비

**어떻게 하나요?**
```sql
-- 주문 원장 기록
INSERT INTO order_ledger(
  order_id, event_type, payload, created_at
) VALUES(
  @order_id, 'ORDER_CONFIRMED', 
  '{"hold_id":"hold_12345", "amount":150000}', NOW()
);

-- 배송/정산 시스템에 알림 준비
INSERT INTO event_outbox(
  event_type, payload, created_at
) VALUES(
  'OrderConfirmed',
  '{"order_id":"order_67890", "user_id":"홍길동", "amount":150000}',
  NOW()
);
```

**실생활 비유**: 
- 주문 원장 = 가게 장부에 "홍길동님 스니커즈 판매" 기록
- 이벤트 = 배송팀에게 "홍길동님 주소로 스니커즈 보내세요" 메모

---

### 🎯 T2 전체 흐름 정리

```sql
-- 1) 결제 중복 체크
SELECT ... FROM idempotency WHERE idem_key = 'payment_abc123';

START TRANSACTION;  -- 트랜잭션 시작

-- 2) 예약 유효성 + 잠금
SELECT ... FROM reservation_hold WHERE hold_id = 'hold_12345' FOR UPDATE;

-- 3) 주문 생성
INSERT INTO orders(...);
INSERT INTO order_items(...);

-- 4) 예약 확정 (같은 트랜잭션!)
UPDATE reservation_hold SET status = 'COMMITTED' WHERE hold_id = 'hold_12345';

-- 5) 기록
INSERT INTO order_ledger(...);
INSERT INTO event_outbox(...);

COMMIT;  -- 모든 것을 한 번에 확정

-- 멱등성 기록
UPDATE idempotency SET status = 'SUCCEEDED', response_json = '...' 
WHERE idem_key = 'payment_abc123';

-- 성공 응답
RETURN { "order_id": "order_67890", "status": "CONFIRMED" };
```

---

## T3 트랜잭션: 정리하기

### 🎯 목표
시간이 지나도 결제하지 않은 예약들을 정리하고 재고 복원하기

### 🎬 시나리오
1. 홍길동님이 오후 2시에 스니커즈를 예약함 (5분 유효)
2. 오후 2시 5분이 지나도 결제 안 함
3. **T3 트랜잭션이 이 예약을 정리해야 함**
4. 재고를 다시 99 → 100으로 복원
5. 다른 사람이 구매할 수 있게 됨

### 🤖 누가 실행하나요?
- **백그라운드 배치 프로세스**가 주기적으로 실행 (예: 10초마다)
- 사용자가 직접 하는 게 아니라 시스템이 자동으로 함

### 📋 처리 순서 (4단계)

#### 1단계: 만료된 예약 찾기

**무엇을 하나요?**
- 시간이 지났는데 아직 HOLD 상태인 예약들 찾기

**어떻게 하나요?**
```sql
-- 만료된 예약들 찾기 (충돌 방지!)
SELECT hold_id, sku_id, user_id, qty 
FROM reservation_hold 
WHERE status = 'HOLD' 
  AND expire_at <= NOW()  -- 만료 시간 지남
FOR UPDATE SKIP LOCKED    -- 🔒 T2가 처리 중인 건은 건너뛰기
LIMIT 1000;               -- 한 번에 너무 많이 처리하지 않기
```

**SKIP LOCKED가 중요한 이유:**

```
상황: hold_12345가 만료 시간이 지났지만, T2가 처리 중

T2 (결제 처리):  hold_12345에 FOR UPDATE 락 걸고 처리 중...
T3 (만료 처리):  SKIP LOCKED로 hold_12345는 건너뛰고 다른 것 처리

만약 SKIP LOCKED가 없다면:
T3이 T2가 끝날 때까지 대기 → 성능 저하
```

**실생활 비유**: 도서관에서 반납 연체 도서를 정리할 때, 누군가 읽고 있는 책은 건너뛰는 것

---

#### 2단계: 상태 변경

**무엇을 하나요?**
- 찾은 예약들의 상태를 'HOLD' → 'EXPIRED'로 변경

**어떻게 하나요?**
```sql
-- 찾은 예약들을 만료 상태로 변경
UPDATE reservation_hold 
SET status = 'EXPIRED', updated_at = NOW()
WHERE hold_id IN ('hold_12345', 'hold_12346', ...)
  AND status = 'HOLD';  -- 혹시 몰라 상태 한 번 더 확인
```

**실생활 비유**: 예약표에 "취소됨" 도장 찍기

---

#### 3단계: 재고 복원

**무엇을 하나요?**
- 예약으로 묶여있던 재고를 다시 판매 가능 상태로 돌려놓기

**어떻게 하나요?**
```sql
-- SKU별로 복원할 수량 계산
SELECT sku_id, SUM(qty) as total_qty
FROM reservation_hold 
WHERE hold_id IN ('hold_12345', 'hold_12346', ...)
GROUP BY sku_id;

-- 재고 복원
UPDATE inventory_counter 
SET available = available + 1  -- 1개 복원
WHERE sku_id = '스니커즈ID';

UPDATE inventory_counter 
SET available = available + 2  -- 2개 복원  
WHERE sku_id = '운동화ID';
```

**실생활 비유**: 예약 취소된 상품을 다시 진열대에 올려놓기

---

#### 4단계: 기록 및 이벤트

**무엇을 하나요?**
- 만료 처리한 것을 영구 기록
- 다른 시스템들에게 "재고 늘어났어요!" 알림

**어떻게 하나요?**
```sql
-- 감사 기록 (각 만료 건별로)
INSERT INTO inventory_ledger(
  sku_id, event_type, qty_delta, hold_id, reason, created_at
) VALUES
  ('스니커즈ID', 'EXPIRE_CREDIT', +1, 'hold_12345', '만료로 인한 복원', NOW()),
  ('운동화ID', 'EXPIRE_CREDIT', +2, 'hold_12346', '만료로 인한 복원', NOW());

-- 이벤트 발송 준비
INSERT INTO event_outbox(
  event_type, payload, created_at
) VALUES
  ('ReservationExpired', '{"hold_id":"hold_12345", "sku_id":"스니커즈ID"}', NOW()),
  ('ReservationExpired', '{"hold_id":"hold_12346", "sku_id":"운동화ID"}', NOW());

-- 1인 1개 제한 해제
DELETE FROM user_active_hold 
WHERE hold_id IN ('hold_12345', 'hold_12346', ...);
```

**실생활 비유**: 
- 가계부에 "예약 취소로 인한 재고 증가" 기록
- 재고 관리팀에 "진열 수량 업데이트하세요" 알림

---

### 🎯 T3 전체 흐름 정리

```sql
-- 주기적으로 실행 (예: 10초마다)
WHILE TRUE DO
  START TRANSACTION;
  
  -- 1) 만료된 예약 찾기
  SELECT hold_id, sku_id, qty FROM reservation_hold 
  WHERE status = 'HOLD' AND expire_at <= NOW()
  FOR UPDATE SKIP LOCKED LIMIT 1000;
  
  IF no_rows_found THEN
    COMMIT;
    SLEEP 10; -- 10초 대기
    CONTINUE;
  END IF;
  
  -- 2) 상태 변경
  UPDATE reservation_hold SET status = 'EXPIRED' 
  WHERE hold_id IN (...);
  
  -- 3) 재고 복원
  UPDATE inventory_counter SET available = available + qty 
  WHERE sku_id = ...;
  
  -- 4) 기록
  INSERT INTO inventory_ledger(...);
  INSERT INTO event_outbox(...);
  DELETE FROM user_active_hold WHERE hold_id IN (...);
  
  COMMIT;
END WHILE;
```

### ⚠️ T3의 장애 처리

T3는 중간에 실패할 수 있어요. 이때를 대비한 안전장치들:

#### 멱등성 보장
```sql
-- 원장에 중복 기록 방지
CREATE UNIQUE INDEX uk_ledger_expire ON inventory_ledger(event_type, hold_id)
WHERE event_type = 'EXPIRE_CREDIT';

-- 이미 처리된 건은 다시 처리 안 함
INSERT INTO inventory_ledger(...) ON DUPLICATE KEY UPDATE ledger_id = ledger_id;
```

#### 보정 배치
```sql
-- 주기적으로 재고 일관성 확인
SELECT sku_id,
  (SELECT available FROM inventory_counter WHERE sku_id = l.sku_id) as counter_value,
  SUM(qty_delta) as ledger_total
FROM inventory_ledger l
GROUP BY sku_id
HAVING counter_value != ledger_total;  -- 불일치 발견 시 알림
```

---

## 트랜잭션 간 상호작용

### 🔄 정상 흐름

```
사용자: 구매 버튼 클릭
   ↓
T1: 예약 생성 (재고 100 → 99)
   ↓
사용자: 결제 진행
   ↓  
T2: 주문 확정 (예약 HOLD → COMMITTED)
   ↓
완료: 스니커즈 배송
```

### ⏰ 만료 흐름

```
사용자: 구매 버튼 클릭
   ↓
T1: 예약 생성 (재고 100 → 99)
   ↓
사용자: 결제 안 함 (5분 경과)
   ↓
T3: 만료 처리 (재고 99 → 100, 예약 HOLD → EXPIRED)
   ↓
다른 사용자: 구매 가능
```

### 🏃‍♂️ 경합 상황

**시나리오**: T2와 T3가 같은 예약을 동시에 처리하려는 경우

```
시간: 14:05:00 (만료 시간)
T2: 결제 처리 시작 → hold_12345에 FOR UPDATE 락 걸기
T3: 만료 처리 시작 → FOR UPDATE SKIP LOCKED로 hold_12345 건너뛰기

결과: T2만 처리됨 (주문 확정), T3는 다른 예약 처리
```

**시나리오**: T3가 먼저 처리한 경우

```
시간: 14:05:01 (만료 시간 1초 후)
T3: 만료 처리 먼저 시작 → hold_12345 EXPIRED로 변경
T2: 결제 처리 시도 → status != 'HOLD' 확인 → 실패 (이미 만료됨)

결과: T3만 처리됨 (만료), T2는 "결제 실패" 응답
```

---

## 장애 상황별 대응

### 💥 T1 실행 중 서버 크래시

**상황**: 재고는 차감했는데 예약 생성 전에 서버가 죽음

```sql
-- 실행됨
UPDATE inventory_counter SET available = available - 1 WHERE sku_id = 123;

-- 실행 안 됨 (서버 크래시)
INSERT INTO reservation_hold(...);
```

**결과**: 트랜잭션 롤백 → 재고 차감도 취소됨

**대응**: 클라이언트에서 오류 받고 재시도

---

### 💥 T2 실행 중 네트워크 단절

**상황**: 주문은 생성했는데 응답을 못 받음

```sql
-- 실행됨
INSERT INTO orders(...);
UPDATE reservation_hold SET status = 'COMMITTED';
COMMIT;

-- 네트워크 단절로 응답 못 받음
```

**결과**: 실제로는 주문 완료됨

**대응**: 클라이언트에서 주문 조회 API로 확인

---

### 💥 T3 실행 중 부분 실패

**상황**: 상태는 변경했는데 재고 복원 전에 실패

```sql
-- 실행됨
UPDATE reservation_hold SET status = 'EXPIRED';

-- 실행 안 됨 (서버 크래시)
UPDATE inventory_counter SET available = available + 1;
```

**대응**: 
1. 원장 기반 멱등성으로 재시도 안전
2. 보정 배치가 주기적으로 불일치 수정

---

## 🎯 핵심 포인트 요약

### T1 (예약)의 핵심
- **조건부 UPDATE**: `available >= qty` 조건으로 안전한 재고 차감
- **멱등성**: 같은 요청은 한 번만 처리
- **원자성**: 6단계가 모두 성공하거나 모두 실패

### T2 (결제)의 핵심  
- **FOR UPDATE**: 동시 확정 방지
- **유효성 검사**: 만료/상태 확인
- **원자성**: 주문 생성과 예약 확정을 함께

### T3 (정리)의 핵심
- **SKIP LOCKED**: T2와의 충돌 회피
- **배치 처리**: 한 번에 적정량만 처리
- **멱등성**: 여러 번 실행해도 안전

### 전체 시스템의 핵심
- **3단계 분리**: 각각의 책임이 명확
- **트랜잭션 보장**: ACID 속성 활용
- **장애 복구**: 멱등성과 보정으로 일관성 유지

이 시스템으로 **절대 101켤레가 팔릴 수 없고**, **사용자 경험도 좋고**, **장애 상황에서도 안전**합니다! 🎉
