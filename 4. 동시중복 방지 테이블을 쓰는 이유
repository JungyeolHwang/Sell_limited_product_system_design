동시중복 방지 테이블 (user_active_hold) 은 왜 쓰는건지 모르겠어 멱등성 테이블로 충분하지가 않은건가?
ChatGPT의 말:

좋은 포인트예요! 결론부터 말하면 **멱등성 테이블(idempotency)**은 “같은 요청을 여러 번 보냈을 때”만 막아주고, **동시중복 방지 테이블(user_active_hold)**은 “같은 사람이 서로 다른 요청키로 동시/다중 시도를 할 때”를 막아줍니다. 두 장치는 겹치지 않고 역할이 달라서 둘 다 있어야 합니다.

왜 user_active_hold가 필요한가

멱등성은 “요청 단위” 보장이지 “사람 단위” 보장이 아님

멱등성 키(idem_key)는 보통 요청마다 새로 생성됩니다(탭 새로고침, 앱 재시도 로직, 기기 A/B, 브라우저 A/B).

같은 사용자가 다른 idem_key로 동시에 T1(예약)을 두 번 누르면, 멱등성 테이블은 각각을 서로 다른 새로운 요청으로 보고 둘 다 통과시킬 수 있습니다.

이때 **user_active_hold의 PK(예: (sale_id, user_id) 유니크)**가 “1인 1개(1명 1건의 활성 예약)” 규칙을 데이터 레벨에서 강제하여, 첫 INSERT만 성공시키고 나머지는 즉시 실패시켜 중복 예약을 차단합니다.

경합을 “초반에” 끊어 DB 부하를 낮춤 (조기 실패)

T1 순서에서 user_active_hold INSERT를 재고 차감 전에 시도합니다.

이미 같은 사람이 활성 예약이 있으면 바로 DUPLICATE 충돌로 반환 → 재고 카운터(핫스팟) UPDATE 경합까지 가지 않으므로 락 대기/경합을 크게 줄입니다.

즉, “문 앞에서 번호표 중복을 막고” 안으로 들어오지 못하게 해 CPU/락 소모를 절약합니다.

MySQL에서 “조건부 유니크”를 깔끔하게 구현하기 어려움

“HOLD 상태에 대해서만 (user_id, sku_id) 유니크” 같은 **부분 유니크(조건부 유니크)**는 MySQL에서 바로 지원되지 않습니다.

reservation_hold 하나만으로 이 제약을 표현하려면 트리거/체크/별도 집계 테이블 등 복잡도가 올라갑니다.

반면 user_active_hold는 작고 명확한 깃발 테이블로, “현재 활성 예약은 사용자당 1건”을 단일 PK로 직설적으로 강제합니다(읽기·갱신도 가벼움).

다중 기기/브라우저/프로세스 동시 시나리오에서 결정적

같은 유저가 모바일+PC에서 동시에 “구매”를 눌러 서로 다른 idem_key로 T1을 날리면:

멱등성: 두 요청 모두 “새로운 요청”이므로 통과 대상

user_active_hold: 첫 INSERT만 성공, 두 번째는 즉시 DUPLICATE → 실패

결과적으로 동시중복을 테이블 제약으로 확실하게 차단합니다.

수명·해제 관리가 간단

T2(결제 확정)에서 주문이 성공하면 그 즉시 user_active_hold에서 해당 사용자의 깃발을 DELETE하여 다음 구매를 허용합니다.

T3(만료 배치)에서는 만료된 예약의 깃발도 함께 정리합니다.

깃발 테이블이 있으니 “이 사용자가 지금 활성 예약이 있나?” 조회가 단일 키 조회로 매우 빠릅니다.

간단 레이스 예시(텍스트 시뮬레이션)

동시 T1-요청A(idem_key=A), T1-요청B(idem_key=B) — 같은 user, 같은 sale

요청A: INSERT user_active_hold(sale_id, user_id) → 성공

요청B: 같은 키로 INSERT → PK 충돌 즉시 실패 (여기서 컷)

요청A만 다음 단계(재고 차감 등)로 진행
→ 동시중복 예약 방지 완성

정리

멱등성 테이블: “같은 요청키”의 재시도/중복 전송을 1회 처리로 만들어줌(네트워크 재전송, PG 웹훅 중복 등).

user_active_hold: “같은 유저의 서로 다른 요청키”로 발생하는 동시중복 예약을 데이터 제약으로 차단(1인 1건 규칙).

둘을 함께 써야 재시도/중복 + 동시중복을 모두 막을 수 있습니다.