
0. 멱등성 테이블을 쓰는 이유
멱등성 테이블은 같은 요청이 여러 번 들어와도 한 번만 처리되도록 보장하는 안전핀 역할을 합니다. 
사용자가 더블클릭을 하거나 브라우저를 새로고침하고, 네트워크 재시도나 PG(결제사) 웹훅이 중복으로 전송되는 상황에서 
중복 처리를 방지합니다. 이 테이블은 트랜잭션의 첫 줄에서 실행되어 중복 요청이 동시에 들어올 때 유니크 제약으로 
단 한 요청만 "이 키의 주인"이 되도록 합니다. 
T1(예약)에서는 중복 재고 차감을 방지하고, T2(주문)에서는 PG 중복 알림으로 인한 중복 주문 생성을 방지하는 역할을 합니다.

1. 예약 테이블이 있는데 동시중복예약 방지 테이블을 쓰는 이유
멱등성 테이블과 동시중복예약 방지 테이블은 서로 다른 역할을 합니다. 
멱등성 테이블은 "같은 요청키"의 재시도나 중복 전송을 1회만 처리하도록 만들지만, 
동시중복방지 테이블은 "같은 유저의 서로 다른 요청키"로 발생하는 동시중복 예약을 차단합니다. 

핵심적으로 (sale_id, user_id) 기본키를 통해 "1명 1건의 활성 예약" 규칙을 데이터베이스 레벨에서 강제합니다. 
이를 통해 재고 차감 전에 중복을 차단하여 데이터베이스 부하를 줄이는 조기 실패 메커니즘을 제공합니다. 

예를 들어 홍길동이 스니커즈를 예약(HOLD)한 후 만료(EXPIRED)되면, reservation_hold 테이블에 같은 (user_id, sale_id) 조합의 기록이 남아있게 됩니다. 
만약 reservation_hold 테이블에 UNIQUE(user_id, sale_id) 제약을 걸면, 홍길동이 나중에 다시 같은 상품을 예약하려고 할 때
 "이미 존재하는 조합"이라는 에러가 발생하여 재예약이 불가능해집니다. 
 PostgreSQL 같은 데이터베이스는 "CREATE UNIQUE INDEX ... WHERE status='HOLD'" 같은 조건부 유니크 인덱스를 지원하여 
 HOLD 상태일 때만 유니크 제약을 적용할 수 있지만, MySQL은 이런 기능을 제공하지 않습니다. 
 따라서 HOLD 상태의 예약만 따로 관리하는 user_active_hold라는 깃발 테이블을 별도로 만들어서, 
 예약 시작 시 깃발을 꽂고 예약 완료나 만료 시 깃발을 제거하는 방식으로 "현재 활성 예약은 사용자당 1건만" 규칙을 구현해야 합니다. 
모바일과 PC에서 동시에 구매를 시도할 때 첫 번째 INSERT만 성공하고 나머지는 즉시 실패하도록 보장합니다.

2. 예약 테이블에 상태 전이가 필요한이유
상태 전이는 데이터를 삭제하지 않고 status 컬럼 값만 변경하는 방식입니다. 이는 추적 가능성을 보장하는데, 만약 DELETE로 행을 지워버리면
 "왜 실패했는지"에 대한 기록이 사라지지만, EXPIRED 상태로 남기면 언제 예약했지만 결제를 안 해서 만료됐다는 이력을 추적할 수 있습니다. 
 또한 동시성 충돌을 방지하는 역할도 하는데, T2(결제)와 T3(만료)가 동시에 실행될 때 DELETE를 사용하면 T2가 "예약이 없다"고 판단하지만,
 status 변경 방식은 안전한 실패 처리가 가능합니다. 마지막으로 원장과의 정합성을 유지하여 재고가 "왜 늘었고 줄었는지"에 대한 기록을 보존함으로써 장애 시 재조정이 가능합니다.

3. 이벤트 발송용 테이블이 필요한이유
이벤트 발송용 테이블은 Outbox 패턴을 구현하여 외부 시스템으로의 이벤트 전파를 안전하게 처리합니다. 
“주문이 성공하면 배송이나 마케팅 같은 외부 시스템에도 알림을 보내야 합니다. 
그런데 외부 호출을 트랜잭션 안에서 직접 하면, 중간에 서버가 죽을 때 주문은 성공했는데 알림이 안 나가거나, 
반대로 주문은 실패했는데 알림이 나가는 문제가 생길 수 있습니다. 
그래서 이벤트 발송용 테이블을 두고, 주문 트랜잭션이 커밋될 때 ‘발송할 이벤트’를 먼저 안전하게 기록합니다. 
이후 별도 워커가 이 테이블을 읽어 외부로 전달하므로, 장애가 있어도 이벤트가 유실되거나 중복 발송되는 위험을 막을 수 있습니다.”
또한 주문테이블에 메시지 발송 컬럼을 추가할수도 있다는 아이디어도 있을 수 있는데 이는 
“주문 테이블에 단순히 ‘메시지 발송 여부’ 컬럼을 두면,
 주문은 본질적으로 비즈니스 데이터인데 기술적인 상태값이 섞여 도메인이 오염됩니다. 
 또 주문 1건에서 여러 이벤트가 발생할 수 있는데 컬럼 하나로는 추적과 재시도가 불가능합니다. 
 그래서 이벤트 발송은 반드시 별도 Outbox 테이블로 분리해야 안정성과 확장성을 모두 보장할 수 있습니다.”

4. 결제 프로세스에서 예약정보 테이블 데이터 조회시 FOR UPDATE를 쓰는 이유
FOR UPDATE는 동시에 들어오는 요청을 직렬화해서 한 명씩만 확정하게 만드는 안전장치 역할을 합니다. 
FOR UPDATE 없이 처리하면 서버 A와 B가 거의 동시에 HOLD 상태를 조회해서 둘 다 유효하다고 착각하여 각각 주문을 생성하고 재고를 2번 차감하는 중복 확정이 발생합니다. 
반면 FOR UPDATE를 사용하면 첫 번째 서버가 행 락을 획득하고 주문을 생성한 후 커밋할 때까지 두 번째 서버는 대기하게 되고, 
락이 해제된 후 조회하면 이미 COMMITTED 상태임을 확인하고 처리를 중단합니다. 이렇게 해서 같은 예약에 대해 절대 두 개의 주문이 생성될 수 없도록 보장합니다.

5. 결제 프로세스에서 1인 1개 제한을 풀기 위해 동시중복예약 방지 테이블 데이터를 삭제하는 이유
동시중복예약 방지 테이블은 단순히 “이 사용자가 지금 활성 예약을 가지고 있는가?” 를 추적하는 깃발 테이블입니다.
따라서 예약이 더 이상 유효하지 않을 때, 즉 T2(결제 확정) 으로 주문이 성공했거나 T3(만료 배치) 로 예약이 만료되었을 때는 반드시 해당 사용자의 깃발을 삭제해야 합니다.
1인 1개 제한 자체는 주문 테이블의 UNIQUE 제약으로 보장하며, 깃발 테이블은 오직 현재 예약 중인지 여부만 빠르게 조회하기 위한 용도입니다.
즉, 예약이 확정되거나 만료된 후에는 깃발을 제거해야 사용자가 다시 정상적으로 예약을 시도할 수 있습니다.

6. 예약 원장, 주문 원장 테이블을 쓰는 이유
원장 테이블들은 불변 감사 로그 역할을 하여 모든 변화를 추적합니다. 이들은 "언제, 누가, 몇 개를 가져갔는지" 모든 재고 변화를 INSERT 전용으로 기록하여 감사 추적을 가능하게 합니다. 
주기적으로 원장의 합계와 재고 카운터 값을 비교함으로써 데이터 불일치를 감지하고 자동 복구할 수 있는 정합성 검증 기능을 제공합니다. 
서버가 크래시되는 상황에서도 원장을 기반으로 재고 상태를 복원할 수 있는 장애 복구 능력을 갖추고 있습니다. 
또한 inventory_ledger는 재고 변화를, order_ledger는 주문 기록을 담당하는 역할 분리를 통해 각각의 책임을 명확히 구분합니다.

7. 트랜잭션3에서 만료된 예약을 찾을때 FOR UPDATE SKIP LOCKED를 쓰는 이유
FOR UPDATE SKIP LOCKED는 T2(결제)와 T3(만료)의 경합을 안전하게 회피하는 메커니즘입니다. 
T2가 특정 예약에 대해 락을 잡고 있다면 T3는 그 예약을 건너뛰고 다른 처리 가능한 예약들만 선택합니다. 
이를 통해 두 트랜잭션이 서로를 기다리는 데드락 상황을 방지하고, 대기 없이 즉시 처리 가능한 예약들만 선택하여 성능을 향상시킵니다. 
결과적으로 T2와 T3가 동시에 실행되어도 충돌 없이 안전하게 처리할 수 있으며, 한 쪽이 처리 중인 예약은 다른 쪽에서 자동으로 제외되어 이중 처리를 방지합니다.


8. 사용자 식별자를 BIGINT로 설계하는 이유
사용자 식별자로 BIGINT를 사용하는 것은 사용자가 보는 로그인 ID와 시스템 내부 ID를 분리하는 설계 원칙 때문입니다. 
사용자가 실제로 사용하는 로그인 ID는 "hong123", "john_doe@email.com" 같은 문자열이지만, 
데이터베이스 내부에서는 987654321 같은 숫자 ID로 모든 관계를 관리합니다. 
이렇게 분리하는 이유는 

첫째, 성능상 이점으로 VARCHAR 비교보다 BIGINT 비교가 훨씬 빠르고 인덱스 효율성이 높기 때문입니다. 
둘째, 저장공간 효율성으로 100만 건 기준 VARCHAR(50)는 50MB, BIGINT는 8MB로 6배 이상 공간을 절약할 수 있습니다. 
셋째, 보안상 이유로 URL에 숫자 ID를 노출하면 다른 사용자 정보를 추측하기 어렵지만 로그인 ID를 노출하면 공격 대상이 됩니다. 
넷째, 확장성 측면에서 글로벌 서비스에서 수억 명의 사용자와 한정판 이벤트의 폭발적 트래픽을 고려하면 BIGINT가 필수적입니다. 
마지막으로 사용자가 이메일이나 로그인 ID를 변경해도 내부 user_id는 그대로 유지되어 기존 주문 데이터에 영향을 주지 않는 안정성을 제공합니다.


9. 멱등성 테이블에서 request_hash를 사용하는 이유
멱등성 테이블에서 request_hash는 같은 멱등성 키로 서로 다른 요청이 들어오는 것을 방지하는 핵심 안전장치입니다. 
멱등성 키만으로는 악의적인 키 재사용이나 실수로 인한 키 중복을 감지할 수 없기 때문에 
요청의 완전한 정체성을 확보하기 위해 method+path+body의 SHA-256 해시값을 함께 저장합니다. 
예를 들어 사용자가 같은 멱등성 키 "abc-123"으로 첫 번째는 "스니커즈 1켤레" 요청을, 두 번째는 "운동화 5켤레" 요청을 보낸다면, 
키는 같지만 request_hash가 다르므로 시스템이 이를 감지하고 409 Conflict 에러를 반환합니다. 
SHA-256을 선택한 이유는 현재 안전한 해시 표준이며 32바이트로 적당한 크기이고 충돌 확률이 거의 0에 가깝기 때문입니다. 
이를 통해 네트워크 중간자 공격으로 요청이 변조되거나 개발자 실수로 같은 키가 재사용되는 상황에서도 요청의 무결성을 보장할 수 있습니다. 
결과적으로 멱등성 키와 request_hash를 함께 사용함으로써 "진짜 같은 요청"인지 정확히 판단하여 멱등성의 완전성을 보장합니다. 

10. SERIALIZABLE 격리 수준 사용에 대한 질문
"SERIALIZABLE 격리 수준을 사용하면 동시성 문제가 해결되지 않나요?"라는 질문에 대한 답변입니다.
이론적으로는 SERIALIZABLE이 가장 강력한 격리 수준이지만 실제 대용량 서비스에서는 성능상 큰 문제가 있습니다.
SERIALIZABLE은 모든 트랜잭션을 직렬화하여 실행하므로 동시성이 크게 떨어지고, 초당 수천 건의 요청이 몰리는 한정판 상황에서는 처리량이 급격히 감소합니다.
또한 트랜잭션 충돌 시 롤백이 빈번하게 발생하여 사용자에게 재시도 에러가 많이 노출되고, 데드락 발생 가능성도 높아집니다.
반면 우리가 사용하는 조건부 UPDATE 방식은 READ COMMITTED 수준에서도 안전하게 작동하면서 높은 성능을 보장합니다.
"available >= qty" 조건을 통한 원자적 차감과 유니크 제약을 조합하면 SERIALIZABLE의 안전성을 얻으면서도 훨씬 효율적으로 처리할 수 있습니다.

11. MySQL GET_LOCK을 이용한 분산 락 사용에 대한 질문
"MySQL의 GET_LOCK 함수로 분산 락을 구현하면 안 되나요?"라는 질문에 대한 답변입니다.
GET_LOCK은 단순한 네임드 락 기능으로 트랜잭션과 독립적으로 동작하기 때문에 데이터 일관성 보장에 한계가 있습니다.
트랜잭션이 롤백되어도 락은 유지되거나, 반대로 트랜잭션은 커밋됐는데 락이 먼저 해제되는 타이밍 이슈가 발생할 수 있습니다.
또한 서버가 크래시될 때 락이 자동으로 해제되지만 정확한 해제 시점을 보장할 수 없어 장애 복구 시 불확실성이 증가합니다.
가장 큰 문제는 락과 실제 데이터 변경이 별개로 관리되어 락을 획득했지만 데이터는 이미 다른 프로세스에 의해 변경된 경우를 완전히 배제할 수 없다는 점입니다.
우리 시스템에서는 데이터베이스의 트랜잭션 메커니즘과 제약 조건을 활용하여 락과 데이터 변경을 원자적으로 처리함으로써 더 안전하고 예측 가능한 동작을 보장합니다.

12. Redis만으로 재고 관리하는 방안에 대한 질문
"Redis로 재고를 관리하면 더 빠르지 않나요?"라는 질문에 대한 답변입니다.
Redis는 확실히 메모리 기반이라 속도가 빠르고 원자적 연산(DECR, INCR)을 지원하여 재고 차감에 유리해 보입니다.
하지만 Redis는 기본적으로 캐시 솔루션이므로 데이터의 영속성과 일관성 측면에서 한계가 있습니다.
Redis 인스턴스가 크래시되거나 네트워크 파티션이 발생하면 재고 데이터가 유실될 위험이 있고, 복제 지연으로 인한 데이터 불일치 문제도 발생할 수 있습니다.
또한 Redis만으로는 복잡한 비즈니스 로직(예약, 만료, 원장 기록)을 구현하기 어렵고, 트랜잭션 범위가 제한적이어서 여러 테이블 간의 일관성을 보장하기 힘듭니다.
가장 적절한 접근은 데이터베이스를 "소스 오브 트루스"로 유지하면서 Redis를 읽기 성능 향상을 위한 캐시 계층으로 활용하는 것입니다.
실제 재고 차감과 주문 생성은 반드시 데이터베이스에서 수행하고, Redis는 실시간 재고 조회나 대시보드 표시용으로만 사용하여 안정성과 성능을 모두 확보할 수 있습니다.

13. 리플리카에서 재고를 읽고 의사결정하는 방안에 대한 질문
"리플리카 DB에서 재고를 조회해서 주문 가능 여부를 판단하면 안 되나요?"라는 질문에 대한 답변입니다.
이는 절대 해서는 안 되는 매우 위험한 접근 방식입니다.
리플리카는 마스터 DB와 복제 지연(replication lag)이 있어서 실제보다 많은 재고가 조회될 수 있고, 이를 기반으로 주문을 허용하면 초과 주문이 발생합니다.
예를 들어 실제 재고가 0개인데 리플리카 지연으로 10개로 조회되면, 10명이 동시에 주문을 시도할 수 있게 되어 재고 초과 판매라는 치명적인 문제가 발생합니다.
특히 한정판 상품처럼 높은 트래픽이 몰리는 상황에서는 복제 지연이 더욱 커질 수 있어 위험성이 증가합니다.
또한 리플리카의 데이터를 기반으로 비즈니스 의사결정을 하면 일관성 없는 사용자 경험을 제공하게 되어 고객 불만과 브랜드 신뢰도 하락으로 이어집니다.
올바른 접근은 읽기용 조회(상품 목록, 대시보드)는 리플리카를 활용하되, 주문이나 재고 차감 같은 중요한 의사결정은 반드시 마스터 DB의 트랜잭션 내에서 수행하는 것입니다.
이렇게 읽기와 쓰기를 명확히 분리하여 성능과 안정성을 모두 확보해야 합니다.