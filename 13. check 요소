
0. 멱등성 테이블을 쓰는 이유
멱등성 테이블은 같은 요청이 여러 번 들어와도 한 번만 처리되도록 보장하는 안전핀 역할을 합니다. 
사용자가 더블클릭을 하거나 브라우저를 새로고침하고, 네트워크 재시도나 PG(결제사) 웹훅이 중복으로 전송되는 상황에서 
중복 처리를 방지합니다. 이 테이블은 트랜잭션의 첫 줄에서 실행되어 중복 요청이 동시에 들어올 때 유니크 제약으로 
단 한 요청만 "이 키의 주인"이 되도록 합니다. 
T1(예약)에서는 중복 재고 차감을 방지하고, T2(주문)에서는 PG 중복 알림으로 인한 중복 주문 생성을 방지하는 역할을 합니다.

1. 예약 테이블이 있는데 동시중복예약 방지 테이블을 쓰는 이유
멱등성 테이블과 동시중복예약 방지 테이블은 서로 다른 역할을 합니다. 
멱등성 테이블은 "같은 요청키"의 재시도나 중복 전송을 1회만 처리하도록 만들지만, 
동시중복방지 테이블은 "같은 유저의 서로 다른 요청키"로 발생하는 동시중복 예약을 차단합니다. 
핵심적으로 (sale_id, user_id) 기본키를 통해 "1명 1건의 활성 예약" 규칙을 데이터베이스 레벨에서 강제합니다. 
이를 통해 재고 차감 전에 중복을 차단하여 데이터베이스 부하를 줄이는 조기 실패 메커니즘을 제공합니다. 
MySQL이 조건부 유니크(HOLD 상태에서만 유니크)를 지원하지 않기 때문에 별도 테이블이 필요하며, 
모바일과 PC에서 동시에 구매를 시도할 때 첫 번째 INSERT만 성공하고 나머지는 즉시 실패하도록 보장합니다.

2. 상태 전이가 필요한이유
상태 전이는 데이터를 삭제하지 않고 status 컬럼 값만 변경하는 방식입니다. 이는 추적 가능성을 보장하는데, 만약 DELETE로 행을 지워버리면
 "왜 실패했는지"에 대한 기록이 사라지지만, EXPIRED 상태로 남기면 언제 예약했지만 결제를 안 해서 만료됐다는 이력을 추적할 수 있습니다. 
 또한 동시성 충돌을 방지하는 역할도 하는데, T2(결제)와 T3(만료)가 동시에 실행될 때 DELETE를 사용하면 T2가 "예약이 없다"고 판단하지만,
 status 변경 방식은 안전한 실패 처리가 가능합니다. 마지막으로 원장과의 정합성을 유지하여 재고가 "왜 늘었고 줄었는지"에 대한 기록을 보존함으로써 장애 시 재조정이 가능합니다.

3. 이벤트 발송용 테이블이 필요한이유
이벤트 발송용 테이블은 Outbox 패턴을 구현하여 외부 시스템으로의 이벤트 전파를 안전하게 처리합니다. 
데이터베이스 트랜잭션과 함께 커밋되기 때문에 이벤트가 절대 빠지지 않는 트랜잭션 원자성을 보장합니다. 
주문 테이블이나 예약 테이블만 보고 이벤트를 발송하면 경계 시간 때문에 일부 주문이 방송되지 않는 유실 문제와 같은 주문이 여러 번 방송되는 중복 문제가 발생할 수 있습니다. 
이벤트 발송용 테이블은 이벤트 발송만을 전담하므로 중복과 유실 없이 안전하게 결제 시스템, 배송 시스템, 알림 시스템 등의 외부 시스템과 분리된 채로 이벤트를 전달할 수 있습니다.

4. 결제 프로세스에서 예약정보 테이블 데이터 조회시 FOR UPDATE를 쓰는 이유
FOR UPDATE는 동시에 들어오는 요청을 직렬화해서 한 명씩만 확정하게 만드는 안전장치 역할을 합니다. 
FOR UPDATE 없이 처리하면 서버 A와 B가 거의 동시에 HOLD 상태를 조회해서 둘 다 유효하다고 착각하여 각각 주문을 생성하고 재고를 2번 차감하는 중복 확정이 발생합니다. 
반면 FOR UPDATE를 사용하면 첫 번째 서버가 행 락을 획득하고 주문을 생성한 후 커밋할 때까지 두 번째 서버는 대기하게 되고, 
락이 해제된 후 조회하면 이미 COMMITTED 상태임을 확인하고 처리를 중단합니다. 이렇게 해서 같은 예약에 대해 절대 두 개의 주문이 생성될 수 없도록 보장합니다.

5. 결제 프로세스에서 1인 1개 제한을 풀기위해 동시중복예약 방지 테이블 데이터를 삭제하는 이유
동시중복예약 방지 테이블은 깃발 테이블의 역할을 하며, 그 수명을 적절히 관리해야 합니다. 
T2(결제 확정) 단계에서 주문이 성공하면 즉시 user_active_hold 테이블에서 해당 사용자의 깃발을 삭제하여 다음 구매를 허용해야 합니다. 
마찬가지로 T3(만료 배치)에서도 만료된 예약의 깃발을 함께 정리합니다. 깃발이 삭제되어야만 같은 사용자가 다시 예약할 수 있고, 이 테이블이 있기 때문에 
"이 사용자가 지금 활성 예약이 있는가?"에 대한 조회를 단일 키 조회로 매우 빠르게 처리할 수 있습니다. 즉, 예약이 완료되거나 만료된 후에는 반드시 깃발을 제거해야 다음 예약이 가능해집니다.

6. 예약 원장, 주문 원장 테이블을 쓰는 이유
원장 테이블들은 불변 감사 로그 역할을 하여 모든 변화를 추적합니다. 이들은 "언제, 누가, 몇 개를 가져갔는지" 모든 재고 변화를 INSERT 전용으로 기록하여 감사 추적을 가능하게 합니다. 
주기적으로 원장의 합계와 카운터 값을 비교함으로써 데이터 불일치를 감지하고 자동 복구할 수 있는 정합성 검증 기능을 제공합니다. 
서버가 크래시되는 상황에서도 원장을 기반으로 재고 상태를 복원할 수 있는 장애 복구 능력을 갖추고 있습니다. 
또한 inventory_ledger는 재고 변화를, order_ledger는 주문 기록을 담당하는 역할 분리를 통해 각각의 책임을 명확히 구분합니다.

7. 트랜잭션3에서 만료된 예약을 찾을때 FOR UPDATE SKIP LOCKED를 쓰는 이유
FOR UPDATE SKIP LOCKED는 T2(결제)와 T3(만료)의 경합을 안전하게 회피하는 메커니즘입니다. 
T2가 특정 예약에 대해 락을 잡고 있다면 T3는 그 예약을 건너뛰고 다른 처리 가능한 예약들만 선택합니다. 
이를 통해 두 트랜잭션이 서로를 기다리는 데드락 상황을 방지하고, 대기 없이 즉시 처리 가능한 예약들만 선택하여 성능을 향상시킵니다. 
결과적으로 T2와 T3가 동시에 실행되어도 충돌 없이 안전하게 처리할 수 있으며, 한 쪽이 처리 중인 예약은 다른 쪽에서 자동으로 제외되어 이중 처리를 방지합니다.
