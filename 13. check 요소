
0. 멱등성 테이블을 쓰는 이유
멱등성 테이블은 같은 요청이 여러 번 들어와도 한 번만 처리되도록 보장하는 안전핀 역할을 합니다. 
사용자가 더블클릭을 하거나 브라우저를 새로고침하고, 네트워크 재시도나 PG(결제사) 웹훅이 중복으로 전송되는 상황에서 
중복 처리를 방지합니다. 이 테이블은 트랜잭션의 첫 줄에서 실행되어 중복 요청이 동시에 들어올 때 유니크 제약으로 
단 한 요청만 "이 키의 주인"이 되도록 합니다. 
T1(예약)에서는 중복 재고 차감을 방지하고, T2(주문)에서는 PG 중복 알림으로 인한 중복 주문 생성을 방지하는 역할을 합니다.

1. 예약 테이블이 있는데 동시중복예약 방지 테이블을 쓰는 이유
멱등성 테이블과 동시중복예약 방지 테이블은 서로 다른 역할을 합니다. 
멱등성 테이블은 "같은 요청키"의 재시도나 중복 전송을 1회만 처리하도록 만들지만, 
동시중복방지 테이블은 "같은 유저의 서로 다른 요청키"로 발생하는 동시중복 예약을 차단합니다. 

핵심적으로 (sale_id, user_id) 기본키를 통해 "1명 1건의 활성 예약" 규칙을 데이터베이스 레벨에서 강제합니다. 
이를 통해 재고 차감 전에 중복을 차단하여 데이터베이스 부하를 줄이는 조기 실패 메커니즘을 제공합니다. 

예를 들어 홍길동이 스니커즈를 예약(HOLD)한 후 만료(EXPIRED)되면, reservation_hold 테이블에 같은 (user_id, sale_id) 조합의 기록이 남아있게 됩니다. 
만약 reservation_hold 테이블에 UNIQUE(user_id, sale_id) 제약을 걸면, 홍길동이 나중에 다시 같은 상품을 예약하려고 할 때
 "이미 존재하는 조합"이라는 에러가 발생하여 재예약이 불가능해집니다. 
 PostgreSQL 같은 데이터베이스는 "CREATE UNIQUE INDEX ... WHERE status='HOLD'" 같은 조건부 유니크 인덱스를 지원하여 
 HOLD 상태일 때만 유니크 제약을 적용할 수 있지만, MySQL은 이런 기능을 제공하지 않습니다. 
 따라서 HOLD 상태의 예약만 따로 관리하는 user_active_hold라는 깃발 테이블을 별도로 만들어서, 
 예약 시작 시 깃발을 꽂고 예약 완료나 만료 시 깃발을 제거하는 방식으로 "현재 활성 예약은 사용자당 1건만" 규칙을 구현해야 합니다. 
모바일과 PC에서 동시에 구매를 시도할 때 첫 번째 INSERT만 성공하고 나머지는 즉시 실패하도록 보장합니다.

2. 예약 테이블에 상태 전이가 필요한이유
상태 전이는 데이터를 삭제하지 않고 status 컬럼 값만 변경하는 방식입니다. 이는 추적 가능성을 보장하는데, 만약 DELETE로 행을 지워버리면
 "왜 실패했는지"에 대한 기록이 사라지지만, EXPIRED 상태로 남기면 언제 예약했지만 결제를 안 해서 만료됐다는 이력을 추적할 수 있습니다. 
 또한 동시성 충돌을 방지하는 역할도 하는데, T2(결제)와 T3(만료)가 동시에 실행될 때 DELETE를 사용하면 T2가 "예약이 없다"고 판단하지만,
 status 변경 방식은 안전한 실패 처리가 가능합니다. 마지막으로 원장과의 정합성을 유지하여 재고가 "왜 늘었고 줄었는지"에 대한 기록을 보존함으로써 장애 시 재조정이 가능합니다.

3. 이벤트 발송용 테이블이 필요한이유
이벤트 발송용 테이블은 Outbox 패턴을 구현하여 외부 시스템으로의 이벤트 전파를 안전하게 처리합니다. 
“주문이 성공하면 배송이나 마케팅 같은 외부 시스템에도 알림을 보내야 합니다. 
그런데 외부 호출을 트랜잭션 안에서 직접 하면, 중간에 서버가 죽을 때 주문은 성공했는데 알림이 안 나가거나, 
반대로 주문은 실패했는데 알림이 나가는 문제가 생길 수 있습니다. 
그래서 이벤트 발송용 테이블을 두고, 주문 트랜잭션이 커밋될 때 ‘발송할 이벤트’를 먼저 안전하게 기록합니다. 
이후 별도 워커가 이 테이블을 읽어 외부로 전달하므로, 장애가 있어도 이벤트가 유실되거나 중복 발송되는 위험을 막을 수 있습니다.”
또한 주문테이블에 메시지 발송 컬럼을 추가할수도 있다는 아이디어도 있을 수 있는데 이는 
“주문 테이블에 단순히 ‘메시지 발송 여부’ 컬럼을 두면,
 주문은 본질적으로 비즈니스 데이터인데 기술적인 상태값이 섞여 도메인이 오염됩니다. 
 또 주문 1건에서 여러 이벤트가 발생할 수 있는데 컬럼 하나로는 추적과 재시도가 불가능합니다. 
 그래서 이벤트 발송은 반드시 별도 Outbox 테이블로 분리해야 안정성과 확장성을 모두 보장할 수 있습니다.”

4. 결제 프로세스에서 예약정보 테이블 데이터 조회시 FOR UPDATE를 쓰는 이유
FOR UPDATE는 동시에 들어오는 요청을 직렬화해서 한 명씩만 확정하게 만드는 안전장치 역할을 합니다. 
FOR UPDATE 없이 처리하면 서버 A와 B가 거의 동시에 HOLD 상태를 조회해서 둘 다 유효하다고 착각하여 각각 주문을 생성하고 재고를 2번 차감하는 중복 확정이 발생합니다. 
반면 FOR UPDATE를 사용하면 첫 번째 서버가 행 락을 획득하고 주문을 생성한 후 커밋할 때까지 두 번째 서버는 대기하게 되고, 
락이 해제된 후 조회하면 이미 COMMITTED 상태임을 확인하고 처리를 중단합니다. 이렇게 해서 같은 예약에 대해 절대 두 개의 주문이 생성될 수 없도록 보장합니다.

5. 결제 프로세스에서 1인 1개 제한을 풀기 위해 동시중복예약 방지 테이블 데이터를 삭제하는 이유
동시중복예약 방지 테이블은 단순히 “이 사용자가 지금 활성 예약을 가지고 있는가?” 를 추적하는 깃발 테이블입니다.
따라서 예약이 더 이상 유효하지 않을 때, 즉 T2(결제 확정) 으로 주문이 성공했거나 T3(만료 배치) 로 예약이 만료되었을 때는 반드시 해당 사용자의 깃발을 삭제해야 합니다.
1인 1개 제한 자체는 주문 테이블의 UNIQUE 제약으로 보장하며, 깃발 테이블은 오직 현재 예약 중인지 여부만 빠르게 조회하기 위한 용도입니다.
즉, 예약이 확정되거나 만료된 후에는 깃발을 제거해야 사용자가 다시 정상적으로 예약을 시도할 수 있습니다.

6. 예약 원장, 주문 원장 테이블을 쓰는 이유
원장 테이블들은 불변 감사 로그 역할을 하여 모든 변화를 추적합니다. 이들은 "언제, 누가, 몇 개를 가져갔는지" 모든 재고 변화를 INSERT 전용으로 기록하여 감사 추적을 가능하게 합니다. 
주기적으로 원장의 합계와 재고 카운터 값을 비교함으로써 데이터 불일치를 감지하고 자동 복구할 수 있는 정합성 검증 기능을 제공합니다. 
서버가 크래시되는 상황에서도 원장을 기반으로 재고 상태를 복원할 수 있는 장애 복구 능력을 갖추고 있습니다. 
또한 inventory_ledger는 재고 변화를, order_ledger는 주문 기록을 담당하는 역할 분리를 통해 각각의 책임을 명확히 구분합니다.

7. 트랜잭션3에서 만료된 예약을 찾을때 FOR UPDATE SKIP LOCKED를 쓰는 이유
FOR UPDATE SKIP LOCKED는 T2(결제)와 T3(만료)의 경합을 안전하게 회피하는 메커니즘입니다. 
T2가 특정 예약에 대해 락을 잡고 있다면 T3는 그 예약을 건너뛰고 다른 처리 가능한 예약들만 선택합니다. 
이를 통해 두 트랜잭션이 서로를 기다리는 데드락 상황을 방지하고, 대기 없이 즉시 처리 가능한 예약들만 선택하여 성능을 향상시킵니다. 
결과적으로 T2와 T3가 동시에 실행되어도 충돌 없이 안전하게 처리할 수 있으며, 한 쪽이 처리 중인 예약은 다른 쪽에서 자동으로 제외되어 이중 처리를 방지합니다.
